CHIP CPU {
    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M?
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    And(a=instruction[15], b=true, out=isCInstruction);
    Not(in=isCInstruction, out=isAInstruction);

    Mux16(a=instruction, b=aluOut, sel=isCInstruction, out=mux1Out);

    Or(a=isAInstruction, b=instruction[5], out=shouldLoadA);
    ARegister(in=mux1Out, load=shouldLoadA, out=aRegisterOut, out[0..14]=addressM);

    Mux16(a=aRegisterOut, b=inM, sel=instruction[12], out=aOrM);

    And(a=isCInstruction, b=instruction[4], out=shouldUpdateD);
    DRegister(in=aluOut, load=shouldUpdateD, out=d);

    ALU(x=d, y=aOrM, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=aluOut, out=outM, zr=aluZr, ng=aluNeg);

    // pc
    Not(in=aluZr, out=notZero);
    Not(in=aluNeg, out=notNeg);
    And(a=notZero, b=notNeg, out=aluPos);

    And(a=instruction[0], b=aluPos, out=jumpPos);
    And(a=instruction[1], b=aluZr, out=jumpZero);
    And(a=instruction[2], b=aluNeg, out=jumpNeg);

    Or(a=jumpPos, b=jumpZero, out=shouldJump1);
    Or(a=shouldJump1, b=jumpNeg, out=shouldJump2);
    And(a=shouldJump2, b=isCInstruction, out=shouldJump);

    Not(in=shouldJump, out=increment);
    PC(in=aRegisterOut, load=shouldJump, inc=increment, reset=reset, out[0..14]=pc);

    // writeM
    And(a=isCInstruction, b=instruction[3], out=writeM);
}
